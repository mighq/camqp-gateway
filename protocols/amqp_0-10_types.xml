<?xml version="1.0" encoding="UTF-8"?>
<!--
  XML Notes
  =========

  We use entities to indicate repetition; attributes to indicate properties.

  We use the "name" attribute as an identifier, usually within the context of the surrounding
  entities.

  We use hyphens (minus char '-') to seperate words in names.

  We do not enforce any particular validation mechanism but we support all mechanisms.  The protocol
  definition conforms to a formal grammar that is published seperately in several technologies.

-->
<!DOCTYPE amqp SYSTEM "amqp_0-10.dtd">

<amqp major="0" minor="10" port="0">
  <!--
    ====================== == type definitions == ======================
  -->

  <!--
    0x00 - 0x0f: Fixed width, 1 octet
  -->

  <type name="bin8" code="0x00" fixed-width="1" label="octet of unspecified encoding">
    <doc>
      The bin8 type consists of exactly one octet of opaque binary data.
    </doc>

    <doc type="picture" title="Wire Format">
         1 OCTET
      +----------+
      |   bin8   |
      +----------+
    </doc>

    <doc type="bnf">
               bin8 = OCTET
    </doc>
  </type>

  <type name="int8" code="0x01" fixed-width="1" label="8-bit signed integral value (-128 - 127)">
    <doc>
      The int8 type is a signed integral value encoded using an 8-bit two's complement
      representation.
    </doc>

    <doc type="picture" title="Wire Format">
         1 OCTET
      +----------+
      |   int8   |
      +----------+
    </doc>

    <doc type="bnf">
               int8 = OCTET
    </doc>
  </type>

  <type name="uint8" code="0x02" fixed-width="1" label="8-bit unsigned integral value (0 - 255)">
    <doc>
      The uint8 type is an 8-bit unsigned integral value.
    </doc>

    <doc type="picture" title="Wire Format">
        1 OCTET
      +---------+
      |  uint8  |
      +---------+
    </doc>

    <doc type="bnf">
              uint8 = OCTET
    </doc>
  </type>

  <type name="char" code="0x04" fixed-width="1" label="an iso-8859-15 character">
    <doc>
      The char type encodes a single character from the iso-8859-15 character set.
    </doc>

    <doc type="picture" title="Wire Format">
         1 OCTET
      +----------+
      |   char   |
      +----------+
    </doc>

    <doc type="bnf">
               char = OCTET
    </doc>
  </type>

  <type name="boolean" code="0x08" fixed-width="1" label="boolean value (zero represents false, nonzero represents true)">
    <doc>
      The boolean type is a single octet that encodes a true or false value. If the octet is zero,
      then the boolean is false. Any other value represents true.
    </doc>

    <doc type="picture" title="Wire Format">
        1 OCTET
      +---------+
      | boolean |
      +---------+
    </doc>

    <doc type="bnf">
            boolean = OCTET
    </doc>
  </type>

  <!--
    0x10 - 0x1f: Fixed width, 2 octets
  -->

  <type name="bin16" code="0x10" fixed-width="2" label="two octets of unspecified binary encoding">
    <doc>
      The bin16 type consists of two consecutive octets of opaque binary data.
    </doc>

    <doc type="picture" title="Wire Format">
         1 OCTET     1 OCTET
      +-----------+-----------+
      | octet-one | octet-two |
      +-----------+-----------+
    </doc>

    <doc type="bnf">
              bin16 = 2 OCTET
    </doc>
  </type>

  <type name="int16" code="0x11" fixed-width="2" label="16-bit signed integral value">
    <doc>
      The int16 type is a signed integral value encoded using a 16-bit two's complement
      representation in network byte order.
    </doc>

    <doc type="picture" title="Wire Format">
         1 OCTET    1 OCTET
      +-----------+----------+
      | high-byte | low-byte |
      +-----------+----------+
    </doc>

    <doc type="bnf">
              int16 = high-byte low-byte
          high-byte = OCTET
           low-byte = OCTET
    </doc>
  </type>

  <type name="uint16" code="0x12" fixed-width="2" label="16-bit unsigned integer">
    <doc>
      The uint16 type is a 16-bit unsigned integral value encoded in network byte order.
    </doc>

    <doc type="picture" title="Wire Format">
         1 OCTET    1 OCTET
      +-----------+----------+
      | high-byte | low-byte |
      +-----------+----------+
    </doc>

    <doc type="bnf">
             uint16 = high-byte low-byte
          high-byte = OCTET
           low-byte = OCTET
    </doc>
  </type>

  <!--
    0x20 - 0x2f: Fixed width, 4 octets
  -->

  <type name="bin32" code="0x20" fixed-width="4" label="four octets of unspecified binary encoding">
    <doc>
      The bin32 type consists of 4 consecutive octets of opaque binary data.
    </doc>

    <doc type="picture" title="Wire Format">
         1 OCTET     1 OCTET      1 OCTET      1 OCTET
      +-----------+-----------+-------------+------------+
      | octet-one | octet-two | octet-three | octet-four |
      +-----------+-----------+-------------+------------+
    </doc>

    <doc type="bnf">
              bin32 = 4 OCTET
    </doc>
  </type>

  <type name="int32" code="0x21" fixed-width="4" label="32-bit signed integral value">
    <doc>
      The int32 type is a signed integral value encoded using a 32-bit two's complement
      representation in network byte order.
    </doc>

    <doc type="picture" title="Wire Format">
         1 OCTET     1 OCTET     1 OCTET    1 OCTET
      +-----------+------------+----------+----------+
      | byte-four | byte-three | byte-two | byte-one |
      +-----------+------------+----------+----------+
          MSB                                 LSB
    </doc>

    <doc type="bnf">
              int32 = byte-four byte-three byte-two byte-one
          byte-four = OCTET ; most significant byte (MSB)
         byte-three = OCTET
           byte-two = OCTET
           byte-one = OCTET ; least significant byte (LSB)
    </doc>
  </type>

  <type name="uint32" code="0x22" fixed-width="4" label="32-bit unsigned integral value">
    <doc>
      The uint32 type is a 32-bit unsigned integral value encoded in network byte order.
    </doc>

    <doc type="picture" title="Wire Format">
         1 OCTET     1 OCTET     1 OCTET    1 OCTET
      +-----------+------------+----------+----------+
      | byte-four | byte-three | byte-two | byte-one |
      +-----------+------------+----------+----------+
          MSB                                 LSB
    </doc>

    <doc type="bnf">
             uint32 = byte-four byte-three byte-two byte-one
          byte-four = OCTET ; most significant byte (MSB)
         byte-three = OCTET
           byte-two = OCTET
           byte-one = OCTET ; least significant byte (LSB)
    </doc>
  </type>

  <type name="float" code="0x23" fixed-width="4" label="single precision IEEE 754 32-bit floating point">
    <doc>
      The float type encodes a single precision 32-bit floating point number. The format and
      operations are defined by the IEEE 754 standard for 32-bit floating point numbers.
    </doc>

    <doc type="picture" title="Wire Format">
              4 OCTETs
      +-----------------------+
      |         float         |
      +-----------------------+
        IEEE 754 32-bit float
    </doc>

    <doc type="bnf">
              float = 4 OCTET ; IEEE 754 32-bit floating point number
    </doc>
  </type>

  <type name="char-utf32" code="0x27" fixed-width="4" label="single unicode character in UTF-32 encoding">
    <doc>
      The char-utf32 type consists of a single unicode character in the UTF-32 encoding.
    </doc>

    <doc type="picture" title="Wire Format">
            4 OCTETs
      +------------------+
      |    char-utf32    |
      +------------------+
        UTF-32 character
    </doc>

    <doc type="bnf">
         char-utf32 = 4 OCTET ; single UTF-32 character
    </doc>
  </type>

  <type name="sequence-no" fixed-width="4" label="serial number defined in RFC-1982">
    <doc>
      The sequence-no type encodes, in network byte order, a serial number as defined in RFC-1982.
      The arithmetic, operators, and ranges for numbers of this type are defined by RFC-1982.
    </doc>

    <doc type="picture" title="Wire Format">
               4 OCTETs
      +------------------------+
      |      sequence-no       |
      +------------------------+
        RFC-1982 serial number
    </doc>

    <doc type="bnf">
        sequence-no = 4 OCTET ; RFC-1982 serial number
    </doc>
  </type>

  <!--
    0x30 - 0x3f: Fixed width types - 8 octets
  -->

  <type name="bin64" code="0x30" fixed-width="8" label="eight octets of unspecified binary encoding">
    <doc>
      The bin64 type consists of eight consecutive octets of opaque binary data.
    </doc>

    <doc type="picture" title="Wire Format">
         1 OCTET     1 OCTET            1 OCTET       1 OCTET
      +-----------+-----------+-----+-------------+-------------+
      | octet-one | octet-two | ... | octet-seven | octet-eight |
      +-----------+-----------+-----+-------------+-------------+
    </doc>

    <doc type="bnf">
              bin64 = 8 OCTET
    </doc>
  </type>

  <type name="int64" code="0x31" fixed-width="8" label="64-bit signed integral value">
    <doc>
      The int64 type is a signed integral value encoded using a 64-bit two's complement
      representation in network byte order.
    </doc>

    <doc type="picture" title="Wire Format">
         1 OCTET      1 OCTET           1 OCTET    1 OCTET
      +------------+------------+-----+----------+----------+
      | byte-eight | byte-seven | ... | byte-two | byte-one |
      +------------+------------+-----+----------+----------+
          MSB                                        LSB
    </doc>

    <doc type="bnf">
              int64 = byte-eight byte-seven byte-six byte-five
                      byte-four byte-three byte-two byte-one
         byte-eight = 1 OCTET ; most significant byte (MSB)
         byte-seven = 1 OCTET
           byte-six = 1 OCTET
          byte-five = 1 OCTET
          byte-four = 1 OCTET
         byte-three = 1 OCTET
           byte-two = 1 OCTET
           byte-one = 1 OCTET ; least significant byte (LSB)
    </doc>
  </type>

  <type name="uint64" code="0x32" fixed-width="8" label="64-bit unsigned integral value">
    <doc>
      The uint64 type is a 64-bit unsigned integral value encoded in network byte order.
    </doc>

    <doc type="picture" title="Wire Format">
         1 OCTET      1 OCTET           1 OCTET    1 OCTET
      +------------+------------+-----+----------+----------+
      | byte-eight | byte-seven | ... | byte-two | byte-one |
      +------------+------------+-----+----------+----------+
          MSB                                        LSB
    </doc>

    <doc type="bnf">
             uint64 = byte-eight byte-seven byte-six byte-five
                      byte-four byte-three byte-two byte-one
         byte-eight = 1 OCTET ; most significant byte (MSB)
         byte-seven = 1 OCTET
           byte-six = 1 OCTET
          byte-five = 1 OCTET
          byte-four = 1 OCTET
         byte-three = 1 OCTET
           byte-two = 1 OCTET
           byte-one = 1 OCTET ; least significant byte (LSB)
    </doc>
  </type>

  <type name="double" code="0x33" fixed-width="8" label="double precision IEEE 754 floating point">
    <doc>
      The double type encodes a double precision 64-bit floating point number. The format and
      operations are defined by the IEEE 754 standard for 64-bit double precision floating point
      numbers.
    </doc>

    <doc type="picture" title="Wire Format">
              8 OCTETs
      +-----------------------+
      |        double         |
      +-----------------------+
        IEEE 754 64-bit float
    </doc>

    <doc type="bnf">
             double = 8 OCTET ; double precision IEEE 754 floating point number
    </doc>
  </type>

  <type name="datetime" code="0x38" fixed-width="8" label="datetime in 64 bit POSIX time_t format">
    <doc>
      The datetime type encodes a date and time using the 64 bit POSIX time_t format.
    </doc>

    <doc type="picture" title="Wire Format">
             8 OCTETs
      +---------------------+
      |      datetime       |
      +---------------------+
        posix time_t format
    </doc>

    <doc type="bnf">
           datetime = 8 OCTET ; 64 bit posix time_t format
    </doc>
  </type>

  <!--
    0x40 - 0x4f: Fixed width types - 16 octets
  -->

  <type name="bin128" code="0x40" fixed-width="16" label="sixteen octets of unspecified binary encoding">
    <doc>
      The bin128 type consists of 16 consecutive octets of opaque binary data.
    </doc>

    <doc type="picture" title="Wire Format">
         1 OCTET     1 OCTET             1 OCTET         1 OCTET
      +-----------+-----------+-----+---------------+---------------+
      | octet-one | octet-two | ... | octet-fifteen | octet-sixteen |
      +-----------+-----------+-----+---------------+---------------+
    </doc>

    <doc type="bnf">
             bin128 = 16 OCTET
    </doc>
  </type>

  <type name="uuid" code="0x48" fixed-width="16" label="UUID (RFC-4122 section 4.1.2) - 16 octets">
    <doc>
      The uuid type encodes a universally unique id as defined by RFC-4122. The format and
      operations for this type can be found in section 4.1.2 of RFC-4122.
    </doc>

    <doc type="picture" title="Wire Format">
          16 OCTETs
      +---------------+
      |     uuid      |
      +---------------+
        RFC-4122 UUID
    </doc>

    <doc type="bnf">
               uuid = 16 OCTET ; RFC-4122 section 4.1.2
    </doc>
  </type>

  <!--
    0x50 - 0x5f: Fixed width types - 32 octets
  -->

  <type name="bin256" code="0x50" fixed-width="32" label="thirty two octets of unspecified binary encoding">
    <doc>
      The bin256 type consists of thirty two consecutive octets of opaque binary data.
    </doc>

    <doc type="picture" title="Wire Format">
         1 OCTET     1 OCTET              1 OCTET            1 OCTET
      +-----------+-----------+-----+------------------+------------------+
      | octet-one | octet-two | ... | octet-thirty-one | octet-thirty-two |
      +-----------+-----------+-----+------------------+------------------+
    </doc>

    <doc type="bnf">
             bin256 = 32 OCTET
    </doc>
  </type>

  <!--
    0x60 - 0x6f: Fixed width types - 64 octets
  -->

  <type name="bin512" code="0x60" fixed-width="64" label="sixty four octets of unspecified binary encoding">
    <doc>
      The bin512 type consists of sixty four consecutive octets of opaque binary data.
    </doc>

    <doc type="picture" title="Wire Format">
         1 OCTET     1 OCTET               1 OCTET            1 OCTET
      +-----------+-----------+-----+-------------------+------------------+
      | octet-one | octet-two | ... | octet-sixty-three | octet-sixty-four |
      +-----------+-----------+-----+-------------------+------------------+
    </doc>

    <doc type="bnf">
             bin512 = 64 OCTET
    </doc>
  </type>

  <!--
    0x70 - 0x7f: Fixed width types - 128 octets
  -->

  <type name="bin1024" code="0x70" fixed-width="128" label="one hundred and twenty eight octets of unspecified binary encoding">
    <doc>
      The bin1024 type consists of one hundred and twenty eight octets of opaque binary data.
    </doc>

    <doc type="picture" title="Wire Format">
         1 OCTET     1 OCTET                 1 OCTET                  1 OCTET
      +-----------+-----------+-----+------------------------+------------------------+
      | octet-one | octet-two | ... | octet-one-twenty-seven | octet-one-twenty-eight |
      +-----------+-----------+-----+------------------------+------------------------+
    </doc>

    <doc type="bnf">
            bin1024 = 128 OCTET
    </doc>
  </type>

  <!--
    0x80 - 0x8f: Variable length - one byte length field (up to 255 octets)
  -->

  <type name="vbin8" code="0x80" variable-width="1" label="up to 255 octets of opaque binary data">
    <doc>
      The vbin8 type encodes up to 255 octets of opaque binary data. The number of octets is first
      encoded as an 8-bit unsigned integral value. This is followed by the actual data.
    </doc>

    <doc type="picture" title="Wire Format">
        1 OCTET   size OCTETs
      +---------+-------------+
      |  size   |   octets    |
      +---------+-------------+
         uint8
    </doc>

    <doc type="bnf">
              vbin8 = size octets
               size = uint8
             octets = 0*255 OCTET ; size OCTETs
    </doc>
  </type>

  <type name="str8-latin" code="0x84" variable-width="1" label="up to 255 iso-8859-15 characters">
    <doc>
      The str8-latin type encodes up to 255 octets of iso-8859-15 characters. The number of octets
      is first encoded as an 8-bit unsigned integral value. This is followed by the actual
      characters.
    </doc>

    <doc type="picture" title="Wire Format">
        1 OCTET        size OCTETs
      +---------+------------------------+
      |  size   |       characters       |
      +---------+------------------------+
        uint16    iso-8859-15 characters
    </doc>

    <doc type="bnf">
         str8-latin = size characters
               size = uint8
         characters = 0*255 OCTET ; size OCTETs
    </doc>
  </type>

  <type name="str8" code="0x85" variable-width="1" label="up to 255 octets worth of UTF-8 unicode">
    <doc>
      The str8 type encodes up to 255 octets worth of UTF-8 unicode. The number of octets of unicode
      is first encoded as an 8-bit unsigned integral value. This is followed by the actual UTF-8
      unicode. Note that the encoded size refers to the number of octets of unicode, not necessarily
      the number of characters since the UTF-8 unicode may include multi-byte character sequences.
    </doc>

    <doc type="picture" title="Wire Format">
        1 OCTET   size OCTETs
      +---------+--------------+
      |  size   | utf8-unicode |
      +---------+--------------+
         uint8
    </doc>

    <doc type="bnf">
               str8 = size utf8-unicode
               size = uint8
       utf8-unicode = 0*255 OCTET ; size OCTETs
    </doc>
  </type>

  <type name="str8-utf16" code="0x86" variable-width="1" label="up to 255 octets worth of UTF-16 unicode">
    <doc>
      The str8-utf16 type encodes up to 255 octets worth of UTF-16 unicode. The number of octets of
      unicode is first encoded as an 8-bit unsigned integral value. This is followed by the actual
      UTF-16 unicode. Note that the encoded size refers to the number of octets of unicode, not the
      number of characters since the UTF-16 unicode will include at least two octets per unicode
      character.
    </doc>

    <doc type="picture" title="Wire Format">
        1 OCTET    size OCTETs
      +---------+---------------+
      |  size   | utf16-unicode |
      +---------+---------------+
         uint8
    </doc>

    <doc type="bnf">
         str8-utf16 = size utf16-unicode
               size = uint8
      utf16-unicode = 0*255 OCTET ; size OCTETs
    </doc>
  </type>

  <!--
    0x90 - 0x9f: Variable length types - two byte length field (up to 65535 octets)
  -->

  <type name="vbin16" code="0x90" variable-width="2" label="up to 65535 octets of opaque binary data">
    <doc>
      The vbin16 type encodes up to 65535 octets of opaque binary data. The number of octets is
      first encoded as a 16-bit unsigned integral value in network byte order. This is followed by
      the actual data.
    </doc>

    <doc type="picture" title="Wire Format">
        2 OCTETs   size OCTETs
      +----------+-------------+
      |   size   |   octets    |
      +----------+-------------+
         uint16
    </doc>

    <doc type="bnf">
             vbin16 = size octets
               size = uint16
             octets = 0*65535 OCTET ; size OCTETs
    </doc>
  </type>

  <type name="str16-latin" code="0x94" variable-width="2" label="up to 65535 iso-8859-15 characters">
    <doc>
      The str16-latin type encodes up to 65535 octets of is-8859-15 characters. The number of octets
      is first encoded as a 16-bit unsigned integral value in network byte order. This is followed
      by the actual characters.
    </doc>

    <doc type="picture" title="Wire Format">
        2 OCTETs        size OCTETs
      +----------+------------------------+
      |   size   |       characters       |
      +----------+------------------------+
         uint16    iso-8859-15 characters
    </doc>

    <doc type="bnf">
        str16-latin = size characters
               size = uint16
         characters = 0*65535 OCTET ; size OCTETs
    </doc>
  </type>

  <type name="str16" code="0x95" variable-width="2" label="up to 65535 octets worth of UTF-8 unicode">
    <doc>
      The str16 type encodes up to 65535 octets worth of UTF-8 unicode. The number of octets is
      first encoded as a 16-bit unsigned integral value in network byte order. This is followed by
      the actual UTF-8 unicode. Note that the encoded size refers to the number of octets of
      unicode, not necessarily the number of unicode characters since the UTF-8 unicode may include
      multi-byte character sequences.
    </doc>

    <doc type="picture" title="Wire Format">
        2 OCTETs   size OCTETs
      +----------+--------------+
      |   size   | utf8-unicode |
      +----------+--------------+
         uint16
    </doc>

    <doc type="bnf">
              str16 = size utf8-unicode
               size = uint16
       utf8-unicode = 0*65535 OCTET ; size OCTETs
    </doc>
  </type>

  <type name="str16-utf16" code="0x96" variable-width="2" label="up to 65535 octets worth of UTF-16 unicode">
    <doc>
      The str16-utf16 type encodes up to 65535 octets worth of UTF-16 unicode. The number of octets
      is first encoded as a 16-bit unsigned integral value in network byte order. This is followed
      by the actual UTF-16 unicode. Note that the encoded size refers to the number of octets of
      unicode, not the number of unicode characters since the UTF-16 unicode will include at least
      two octets per unicode character.
    </doc>

    <doc type="picture" title="Wire Format">
        2 OCTETs    size OCTETs
      +----------+---------------+
      |   size   | utf16-unicode |
      +----------+---------------+
         uint16
    </doc>

    <doc type="bnf">
        str16-utf16 = size utf16-unicode
               size = uint16
      utf16-unicode = 0*65535 OCTET ; size OCTETs
    </doc>
  </type>

  <type name="byte-ranges" variable-width="2" label="byte ranges within a 64-bit payload">
    <doc>
      The byte-ranges type encodes up to 65535 octets worth of non-overlapping, non-touching,
      ascending byte ranges within a 64-bit sequence of bytes. Each range is represented as an
      inclusive lower and upper bound that identifies all the byte offsets included within a given
      range.
    </doc>

    <doc>
      The number of octets of data is first encoded as a 16-bit unsigned integral value in network
      byte order. This is then followed by the encoded representation of the ranges included in the
      set. These MUST be encoded in ascending order, and any two ranges included in a given set MUST
      NOT include overlapping or touching byte offsets.
    </doc>

    <doc>
      Each range is encoded as a pair of 64-bit unsigned integral values in network byte order
      respectively representing the lower and upper bounds for that range. Note that because each
      range is exactly 16 octets, the size in octets of the encoded ranges will always be 16 times
      the number of ranges in the set.
    </doc>

    <doc type="picture" title="Wire Format">
                 +----= size OCTETs =----+
                 |                       |
        2 OCTETs |       16 OCTETs       |
      +----------+-----+-----------+-----+
      |   size   | .../|   range   |\... |
      +----------+---/ +-----------+ \---+
         uint16     / /             \ \
                   / /               \ \
                  / 8 OCTETs   8 OCTETs \
                 +-----------+-----------+
                 |   lower   |   upper   |
                 +-----------+-----------+
                     uint64     uint64
    </doc>

    <doc type="bnf">
        byte-ranges = size *range
               size = uint16
              range = lower upper
              lower = uint64
              upper = uint64
    </doc>
  </type>

  <type name="sequence-set" variable-width="2" label="ranged set representation">
    <doc>
      The sequence-set type is a set of pairs of RFC-1982 numbers representing a discontinuous range
      within an RFC-1982 sequence. Each pair represents a closed interval within the list.
    </doc>

    <doc>
      Sequence-sets can be represented as lists of pairs of positive 32-bit numbers, each pair
      representing a closed interval that does not overlap or touch with any other interval in the
      list. For example, a set containing words 0, 1, 2, 5, 6, and 15 can be represented:
    </doc>

    <doc type="picture">
      [(0, 2), (5, 6), (15, 15)]
    </doc>

    <doc>
      1) The list-of-pairs representation is sorted ascending (as defined by RFC 1982
      (http://www.ietf.org/rfc/rfc1982.txt) ) by the first elements of each pair.
    </doc>

    <doc>
      2) The list-of-pairs is flattened into a list-of-words.
    </doc>

    <doc>
      3) Each word in the list is packed into ascending locations in memory with network byte
      ordering.
    </doc>

    <doc>
      4) The size in bytes, represented as a 16-bit network-byte-order unsigned value, is prepended.
    </doc>

    <doc>
      For instance, the example from above would be encoded:
    </doc>

    <doc type="picture">
      [(0, 2), (5, 6), (15, 15)]                           -- already sorted.
      [0, 2, 5, 6, 15, 15]                                 -- flattened.
      000000000000000200000005000000060000000F0000000F     -- bytes in hex
      0018000000000000000200000005000000060000000F0000000F -- bytes in hex,
                                                              length (24) prepended
    </doc>

    <doc type="picture" title="Wire Format">
                 +----= size OCTETs =----+
                 |                       |
        2 OCTETs |       8 OCTETs        |
      +----------+-----+-----------+-----+
      |   size   | .../|   range   |\... |
      +----------+---/ +-----------+ \---+
         uint16     / /             \ \
                   / /               \ \
                  / /                 \ \
                 / /                   \ \
                / 4 OCTETs       4 OCTETs \
               +-------------+-------------+
               |    lower    |    upper    |
               +-------------+-------------+
                 sequence-no   sequence-no
    </doc>

    <doc type="bnf">
       sequence-set = size *range
               size = uint16         ; length of variable portion in bytes

              range = lower upper   ; inclusive
              lower = sequence-no
              upper = sequence-no
    </doc>
  </type>

  <!--
    0xa0 - 0xaf: Variable length types - four byte length field (up to 4294967295 octets)
  -->

  <type name="vbin32" code="0xa0" variable-width="4" label="up to 4294967295 octets of opaque binary data">
    <doc>
      The vbin32 type encodes up to 4294967295 octets of opaque binary data. The number of octets is
      first encoded as a 32-bit unsigned integral value in network byte order. This is followed by
      the actual data.
    </doc>

    <doc type="picture" title="Wire Format">
        4 OCTETs   size OCTETs
      +----------+-------------+
      |   size   |   octets    |
      +----------+-------------+
         uint32
    </doc>

    <doc type="bnf">
             vbin32 = size octets
               size = uint32
             octets = 0*4294967295 OCTET ; size OCTETs
    </doc>
  </type>

  <type name="map" code="0xa8" variable-width="4" label="a mapping of keys to typed values">
    <doc>
      A map is a set of distinct keys where each key has an associated (type,value) pair. The triple
      of the key, type, and value, form an entry within a map. Each entry within a given map MUST
      have a distinct key. A map is encoded as a size in octets, a count of the number of entries,
      followed by the encoded entries themselves.
    </doc>

    <doc>
      An encoded map may contain up to (4294967295 - 4) octets worth of encoded entries. The size is
      encoded as a 32-bit unsigned integral value in network byte order equal to the number of
      octets worth of encoded entries plus 4. (The extra 4 octets is added for the entry count.) The
      size is then followed by the number of entries encoded as a 32-bit unsigned integral value in
      network byte order. Finally the entries are encoded sequentially.
    </doc>

    <doc>
      An entry is encoded as the key, followed by the type, and then the value. The key is always a
      string encoded as a str8. The type is a single octet that may contain any valid AMQP type
      code. The value is encoded according to the rules defined by the type code for that entry.
    </doc>

    <doc type="picture" title="Wire Format">
                 +------------= size OCTETs =-----------+
                 |                                      |
        4 OCTETs | 4 OCTETs                             |
      +----------+----------+-----+---------------+-----+
      |   size   |  count   | .../|     entry     |\... |
      +----------+----------+---/ +---------------+ \---+
         uint32     uint32     / /                 \ \
                              / /                   \ \
                             / /                     \ \
                            / /                       \ \
                           / /                         \ \
                          / k OCTETs   1 OCTET   n OCTETs \
                         +-----------+---------+-----------+
                         |    key    |  type   |   value   |
                         +-----------+---------+-----------+
                             str8                 *type*
    </doc>

    <doc type="bnf">
                map = size count *entry

               size = uint32             ; size of count and entries in octets
              count = uint32             ; number of entries in the map

              entry = key type value
                key = str8
               type = OCTET              ; type code of the value
              value = *OCTET             ; the encoded value
    </doc>
  </type>

  <type name="list" code="0xa9" variable-width="4" label="a series of consecutive type-value pairs">
    <doc>
      A list is an ordered sequence of (type, value) pairs. The (type, value) pair forms an item
      within the list.  The list may contain items of many distinct types. A list is encoded as a
      size in octets, followed by a count of the number of items, followed by the items themselves
      encoded in their defined order.
    </doc>

    <doc>
      An encoded list may contain up to (4294967295 - 4) octets worth of encoded items. The size is
      encoded as a 32-bit unsigned integral value in network byte order equal to the number of
      octets worth of encoded items plus 4. (The extra 4 octets is added for the item count.) The
      size is then followed by the number of items encoded as a 32-bit unsigned integral value in
      network byte order. Finally the items are encoded sequentially in their defined order.
    </doc>

    <doc>
      An item is encoded as the type followed by the value. The type is a single octet that may
      contain any valid AMQP type code. The value is encoded according to the rules defined by the
      type code for that item.
    </doc>

    <doc type="picture" title="Wire Format">
                 +---------= size OCTETs =---------+
                 |                                 |
        4 OCTETs | 4 OCTETs                        |
      +----------+----------+-----+----------+-----+
      |   size   |  count   | .../|   item   |\... |
      +----------+----------+---/ +----------+ \---+
         uint32     uint32     / /            \ \
                              / /              \ \
                             / 1 OCTET   n OCTETs \
                            +----------+-----------+
                            |   type   |   value   |
                            +----------+-----------+
                                          *type*
    </doc>

    <doc type="bnf">
               list = size count *item

               size = uint32            ; size of count and items in octets
              count = uint32            ; number of items in the list

               item = type value
               type = OCTET             ; type code of the value
              value = *OCTET            ; the encoded value
    </doc>
  </type>

  <type name="array" code="0xaa" variable-width="4" label="a defined length collection of values of a single type">
    <doc>
      An array is an ordered sequence of values of the same type. The array is encoded in as a size
      in octets, followed by a type code, then a count of the number values in the array, and
      finally the values encoded in their defined order.
    </doc>

    <doc>
      An encoded array may contain up to (4294967295 - 5) octets worth of encoded values. The size
      is encoded as a 32-bit unsigned integral value in network byte order equal to the number of
      octets worth of encoded values plus 5. (The extra 5 octets consist of 4 octets for the count
      of the number of values, and one octet to hold the type code for the items in the array.) The
      size is then followed by a single octet that may contain any valid AMQP type code. The type
      code is then followed by the number of values encoded as a 32-bit unsigned integral value in
      network byte order. Finally the values are encoded sequentially in their defined order
      according to the rules defined by the type code for the array.
    </doc>

    <doc type="picture" title="Wire Format">
        4 OCTETs   1 OCTET   4 OCTETs      (size - 5) OCTETs
      +----------+---------+----------+-------------------------+
      |   size   |  type   |  count   |         values          |
      +----------+---------+----------+-------------------------+
         uint32               uint32    *count* encoded *types*
    </doc>

    <doc type="bnf">
              array = size type count values

               size = uint32            ; size of type, count, and values in octets
               type = OCTET             ; the type of the encoded values
              count = uint32            ; number of items in the array

             values = 0*4294967290 OCTET ; (size - 5) OCTETs
    </doc>
  </type>

  <type name="struct32" code="0xab" variable-width="4" label="a coded struct with a 32-bit size">
    <doc>
      The struct32 type describes any coded struct with a 32-bit (4 octet) size. The type is
      restricted to be only coded structs with a 32-bit size, consequently the first six octets of
      any encoded value for this type MUST always contain the size, class-code, and struct-code in
      that order.
    </doc>

    <doc>
      The size is encoded as a 32-bit unsigned integral value in network byte order that is equal to
      the size of the encoded field-data, packing-flags, class-code, and struct-code. The class-code
      is a single octet that may be set to any valid class code. The struct-code is a single octet
      that may be set to any valid struct code within the given class-code.
    </doc>

    <doc>
      The first six octets are then followed by the packing flags and encoded field data. The
      presence and quantity of packing-flags, as well as the specific fields are determined by the
      struct definition identified with the encoded class-code and struct-code.
    </doc>

    <doc type="picture" title="Wire Format">
        4 OCTETs    1 OCTET       1 OCTET     pack-width OCTETs    n OCTETs
      +----------+------------+-------------+-------------------+------------+
      |   size   | class-code | struct-code |   packing-flags   | field-data |
      +----------+------------+-------------+-------------------+------------+
         uint32

                          n = (size - 2 - pack-width)
    </doc>

    <doc type="bnf">
           struct32 = size class-code struct-code packing-flags field-data

               size = uint32

         class-code = OCTET     ; zero for top-level structs
        struct-code = OCTET     ; together with class-code identifies the struct
                                ; definition which determines the pack-width and
                                ; fields

      packing-flags = 0*4 OCTET ; pack-width OCTETs

         field-data = *OCTET    ; (size - 2 - pack-width) OCTETs
    </doc>
  </type>

  <!--
    0xb0 - 0xbf: Reserved
  -->

  <!--
    0xc0 - 0xcf:Fixed width types - 5 octets
  -->

  <type name="bin40" code="0xc0" fixed-width="5" label="five octets of unspecified binary encoding">
    <doc>
      The bin40 type consists of five consecutive octets of opaque binary data.
    </doc>

    <doc type="picture" title="Wire Format">
         1 OCTET     1 OCTET      1 OCTET      1 OCTET      1 OCTET
      +-----------+-----------+-------------+------------+------------+
      | octet-one | octet-two | octet-three | octet-four | octet-five |
      +-----------+-----------+-------------+------------+------------+
    </doc>

    <doc type="bnf">
              bin40 = 5 OCTET
    </doc>
  </type>

  <type name="dec32" code="0xc8" fixed-width="5" label="32-bit decimal value (e.g. for use in financial values)">
    <doc>
      The dec32 type is decimal value with a variable number of digits following the decimal point.
      It is encoded as an 8-bit unsigned integral value representing the number of decimal places.
      This is followed by the signed integral value encoded using a 32-bit two's complement
      representation in network byte order.
    </doc>

    <doc>
      The former value is referred to as the exponent of the divisor. The latter value is the
      mantissa. The decimal value is given by: mantissa / 10^exponent.
    </doc>

    <doc type="picture" title="Wire Format">
        1 OCTET    4 OCTETs
      +----------+----------+
      | exponent | mantissa |
      +----------+----------+
         uint8      int32
    </doc>

    <doc type="bnf">
              dec32 = exponent mantissa
           exponent = uint8
           mantissa = int32
    </doc>
  </type>

  <!--
    0xd0 - 0xdf: Fixed width types - 9 octets
  -->

  <type name="bin72" code="0xd0" fixed-width="9" label="nine octets of unspecified binary encoding">
    <doc>
      The bin72 type consists of nine consecutive octets of opaque binary data.
    </doc>

    <doc type="picture" title="Wire Format">
         1 OCTET     1 OCTET            1 OCTET      1 OCTET
      +-----------+-----------+-----+-------------+------------+
      | octet-one | octet-two | ... | octet-eight | octet-nine |
      +-----------+-----------+-----+-------------+------------+
    </doc>

    <doc type="bnf">
              bin64 = 9 OCTET
    </doc>
  </type>

  <type name="dec64" code="0xd8" fixed-width="9" label="64-bit decimal value (e.g. for use in financial values)">
    <doc>
      The dec64 type is decimal value with a variable number of digits following the decimal point.
      It is encoded as an 8-bit unsigned integral value representing the number of decimal places.
      This is followed by the signed integral value encoded using a 64-bit two's complement
      representation in network byte order.
    </doc>

    <doc>
      The former value is referred to as the exponent of the divisor. The latter value is the
      mantissa. The decimal value is given by: mantissa / 10^exponent.
    </doc>

    <doc type="picture" title="Wire Format">
        1 OCTET    8 OCTETs
      +----------+----------+
      | exponent | mantissa |
      +----------+----------+
         uint8      int64
    </doc>

    <doc type="bnf">
              dec64 = exponent mantissa
           exponent = uint8
           mantissa = int64
    </doc>
  </type>

  <!--
    0xe0 - 0xef: Reserved
  -->

  <!--
    0xf0 - 0xff: Zero-length types
  -->

  <type name="void" code="0xf0" fixed-width="0" label="the void type">
    <doc>
      The void type is used within tagged data structures such as maps and lists to indicate an
      empty value. The void type has no value and is encoded as an empty sequence of octets.
    </doc>
  </type>

  <type name="bit" code="0xf1" fixed-width="0" label="presence indicator">
    <doc>
      The bit type is used to indicate that a packing flag within a packed struct is being used to
      represent a boolean value based on the presence of an empty value. The bit type has no value
      and is encoded as an empty sequence of octets.
    </doc>
  </type>
</amqp>
